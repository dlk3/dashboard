#!/usr/bin/env python

#################################################################################
#  Copyright (C) 2022  David King <dave@daveking.com>
#
#  This Source Code Form is subject to the terms of the Mozilla Public License,
#  v. 2.0.  If a copy of the MPL was not distbuted with this file, You can
#  obtain one at https://mozilla.org/MPL/2.0/.
#################################################################################
#  Fetch weather data from the NOAA web site for a specific location
#  and update a JSON object stored on disk with that information.
#
#  This is designed as a forever loop so that it can be run as a daemon.
#
#  The output format used here is designed specifically to match another app
#  I have that consumes this data.  NOAA provides much more data than this
#  script outputs.
#
#  NOAA updates their current observations roughly every 30 minutes and forecasts
#  about once an hour.
#################################################################################

from astral import LocationInfo				# dnf install python3-astral
from astral.sun import sun
import datetime
from geopy.distance import great_circle		# dnf install python3-geopy
import isodate								# dnf install python3-isodate
import json
import pytz									# dnf install python3-pytz
import requests								# dnf install python3-requests
import sys
import time

#  Logging messages
def log(message):
	timestamp = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
	with open(logfile, 'a') as f:
		print(timestamp, message, file=f)
	
#  Celcius to fahrenheit
def degC2degF(degC):
	try:
		return round((degC * 9/5) + 32)
	except Exception as e:
		log('degC2DegF function threw an exception for value "{}"'.format(degC))
		log(e)
		return None

#  Kilometers per hour to miles per hour
def kmph2mph(kmph):
	try:
		return round(kmph * 0.621371)
	except Exception as e:
		log('kmph2mph function threw an exception for value "{}"'.format(kmph))
		log(e)
		return None
		
#  Parse the ISO8601 date strings with interval/duration specs that NOAA uses
#  in the hourly data
def parseInterval(time_str, tz_string=None):
	"""
	time_str must be an ISO8601-compliant time string, optionally including a
	duration specification, for example: 2020-04-10T16:00:00-00:00/P6DT22H
	          
	This function returns a tuple containing two datetime objects. If a duration
	specification was part of the time_str provided, then "start time" and "end time"
	datetime objects will be returned.  If the time_str was just a simple date and time,
	without any duration specification, then the first element of the tuple will be
	the "start time" datetime object and the second element will be null.
	"""
	list = []
	split_time_str = time_str.split('/')
	list.append(isodate.parse_datetime(split_time_str[0]))
	if len(split_time_str) == 2:
		list.append(list[0] + isodate.parse_duration(split_time_str[1]))
	else:
		list.append(None)
	return list

#  Get latitude, longitude, weather_data_file from the command line
#  Log file name can also be supplied as an optional 4th argument
logfile = None
if len(sys.argv) < 5:
	print('Please provide the latitude, longitude, output, and log file name values on the command line:')
	print('\t{} latitude longitude outputfilename logfilename'.format(sys.argv[0]))
	exit(1)
try:
	latitude = float(sys.argv[1])
	longitude = float(sys.argv[2])
except Exception as e:
	print('Latitude and longitude must be valid floating point numbers')
	print('\t{} latitude longitude outputfilename logfilename'.format(sys.argv[0]))
	exit(1)
weather_data_file = sys.argv[3]
logfile = sys.argv[4]

#  See if writing to the log works
log('{} running'.format(sys.argv[0]))

#  Run the process on a continuous loop with a 30 minute sleep between iterations
while True:

	#  Read in the stored JSON object, if it exists
	try:
		with open(weather_data_file, 'r') as f:
			weather_data = json.load(f)
	except FileNotFoundError:
		weather_data = {}

	#  Run this initial section on a 5 minute loop until it completes successfully
	ok_to_continue = False
	while not ok_to_continue:
		
		#  Assume everything will turn out ok
		ok_to_continue = True
		
		#  Get the NOAA location info, timezone and forecast URL links for this location 
		#  from their "points" service, based on the lat/long.
		#
		#  See this page for info on NOAA's User-Agent string requirements:
		#  https://www.weather.gov/documentation/services-web-api
		headers = {
			'User-Agent': '(David King, dave@daveking.com)',
			'Accept': 'application/geo+json',
			'Cache-Control': 'no-cache'
		}
		url = 'https://api.weather.gov/points/{},{}'.format(latitude, longitude)
		response = requests.get(url, headers=headers)
		if response.status_code == 200:
			r = response.json()

			#  Start populating the JSON object
			weather_data['latitude'] = latitude
			weather_data['longitude'] = longitude
			weather_data['timezone'] = r['properties']['timeZone']
			weather_data['observationStationListURL'] = r['properties']['observationStations']
			weather_data['forecastURL'] = r['properties']['forecast']
			weather_data['forecastGridDataURL'] = r['properties']['forecastGridData']
			weather_data['alertsURL'] = 'https://api.weather.gov/alerts?point={},{}'.format(latitude, longitude)
			
			#  Calculate the UTC offset for this timezone
			tz_now = datetime.datetime.now(pytz.timezone(weather_data['timezone']))
			weather_data['tz_offset'] = tz_now.utcoffset().total_seconds() / 3600
			
			#  Create a Python tzinfo object for later use
			local_tz = datetime.timezone(datetime.timedelta(hours=weather_data['tz_offset']))
			
			#  Put a timestamp into the JSON object
			weather_data['generated'] = datetime.datetime.now(local_tz).strftime('%Y-%m-%dT%H:%M:%S%z')
			
		else:
			log('Status code {} returned for {}'.format(response.status_code, url))
			log('Will wait 5 minutes and then retry')
			ok_to_continue = False
			time.sleep(5 * 60)
			break

		#  Get the list of NOAA observation stations associated with this location
		#  and figure out which one is closest to us
		response = requests.get(weather_data['observationStationListURL'], headers=headers)
		if response.status_code == 200:
			r = response.json()
			nearest = -1
			for feature in r['features']:
				distance = great_circle((latitude, longitude), (feature['geometry']['coordinates'][1], feature['geometry']['coordinates'][0]))
				if nearest == -1 or distance < nearest:
					nearest = distance
					weather_data['observationStationURL'] = feature['id']
		else:
			log('Status code {} returned for {}'.format(response.status_code, weather_data['observationStationListURL']))
			log('Will wait 5 minutes and then retry')
			ok_to_continue = False
			time.sleep(5 * 60)
			break

		#--------------------------   C u r r e n t l y   --------------------------#

		#  Get the current conditions from that observation station
		response = requests.get(weather_data['observationStationURL'] + '/observations/latest', headers=headers)
		if response.status_code == 200:
			r = response.json()
			if 'current' not in weather_data:
				weather_data['current'] = {}

			#  Check to make sure all the data we need is there and put it into
			#  weather_data['current'] if it is
			if 'icon' in r['properties'] and r['properties']['icon']:
				weather_data['current']['icon'] = r['properties']['icon'].split('?')[0] + "?size=large"
			else:
				ok_to_continue = False
			if 'description' in r['properties'] and r['properties']['description']:
				weather_data['current']['description'] = r['properties']['textDescription']
			else:
				ok_to_continue = False
			if 'temperature' in r['properties'] and r['properties']['temperature']['value']:
				weather_data['current']['temperature'] = degC2degF(r['properties']['temperature']['value'])
			else:
				ok_to_continue = False
			if 'windSpeed' in r['properties'] and r['properties']['windSpeed']['value']:
				weather_data['current']['wind_speed'] = kmph2mph(r['properties']['windSpeed']['value'])
			else:
				ok_to_continue = False
			if ok_to_continue:
				#  Pass a flag to the daily step to fill in data from NOAA's daily data
				need_current_forecasts = True 
			else:
				#  If data was missing
				log(json.dumps(r['properties'], indent=4))
				log('Properties we need were missing from {}'.format(weather_data['observationStationURL'] + '/observations/latest'))
				log('Will wait 5 minutes and then retry')
				time.sleep(5 * 60)
				break
		else:
			#  If the requests.get failed
			log('Status code {} returned for {}'.format(response.status_code, weather_data['observationStationURL'] + '/observations/latest'))
			log('Will wait 5 minutes and then retry')
			ok_to_continue = False
			time.sleep(5 * 60)
			break

	#  From here on we can accept missing data, we'll fill it in using what we
	#  have from the previous run
	
	#------------------------------   D a i l y   ------------------------------#

	#  Define a location for the astral function that calculates sunrise and sunset
	astral_location = LocationInfo('dummy_name', 'dummy_region', weather_data['timezone'], latitude, longitude)
			
	#  Get the daily forecasts for the next week for this location
	response = requests.get(weather_data['forecastURL'], headers=headers)
	if response.status_code == 200:
		r = response.json()
		#print(json.dumps(r['properties']['periods'], indent=4))
		daily_data = []
		for days in range(0, 7):
			day = {}
			d = datetime.datetime.now(local_tz) + datetime.timedelta(days=days)
			day['date'] = d.strftime('%Y-%m-%d')
			the_sun = sun(astral_location.observer, date=d)
			day['sunrise'] = the_sun['sunrise'].strftime('%Y-%m-%dT%H:%M:%S%z')
			day['sunset'] = the_sun['sunset'].strftime('%Y-%m-%dT%H:%M:%S%z')
			
			for period in r['properties']['periods']:
				period_starttime = datetime.datetime.strptime(period['startTime'], '%Y-%m-%dT%H:%M:%S%z')
				period_endtime = datetime.datetime.strptime(period['endTime'], '%Y-%m-%dT%H:%M:%S%z')
				if period_starttime.strftime('%Y-%m-%d') == day['date']:
					#  Update current forecasts (take first ones we find)
					if need_current_forecasts:
					
						#  TODO: I'm not sure whether these are nulls or empty
						#  strings when no data is returned and I want to find out
						if period['shortForecast'] and period['detailedForecast']:
							if period['shortForecast'] != '' and period['detailedForecast'] != '':
								weather_data['current']['shortForecast'] = period['shortForecast']
								weather_data['current']['detailedForecast'] = period['detailedForecast']
								need_current_forecasts = False
							else:
								log('NOAA returned period[\'shortForecast\'] or period[\'detailedForecast\'] as an empty string in the daily data')
								log(period)
						else:
							log('NOAA returned period[\'shortForecast\'] or period[\'detailedForecast\'] as null in the daily data')
							log(period)
					
					#  Day-time data
					if period['isDaytime']:
						day['icon'] = period['icon'].split('?')[0] + "?size=large"
						day['high'] = period['temperature']
					#  Night-time data
					else:
						if 'icon' not in day:
							day['icon'] = period['icon'].split('?')[0] + "?size=large"
						#  If there wasn't any day-time period data for this date,
						#  use the current temp as the high
						if 'high' not in day:
							day['high'] = weather_data['current']['temperature']
						day['low'] = period['temperature']
					
					#  Swap high and low if they are reversed
					if ('high', 'low') in day:
						if day['high'] < day['low']:
							t = day['high']
							day['high'] = day['low']
							day['low'] = t
			
			#  Fill in any missing values with data from previous run
			if 'daily' in weather_data:
				for old_day in weather_data['daily']:
					if old_day['date'] == day['date']:
						if 'icon' not in day and 'icon' in old_day:
							day['icon'] = old_day['icon']
						if 'high' not in day and 'high' in old_day:
							day['high'] = old_day['high']
						if 'low' not in day and 'low' in old_day:
							day['low'] = old_day['low']
						break
			
			#  Add the day's data to the array			
			daily_data.append(day)

		#  Update the array in the JSON object
		weather_data['daily'] = daily_data

	else:
		log('Status code {} returned for {}'.format(response.status_code, weather_data['forecastURL']))
		log('The daily weather forcasts have not been updated. Some other data elements may have been updated however.')

	#-----------------------------   H o u r l y   -----------------------------#

	#  Get the hourly forecasts for the next 48 hours for this location
	response = requests.get(weather_data['forecastGridDataURL'], headers=headers)
	if response.status_code == 200:
		r = response.json()
		if 'hourly' not in weather_data:
			weather_data['hourly'] = {}
		hourly_data = []
		for hours in range(0, 48):
			hour = {}
			d = datetime.datetime.now(local_tz) + datetime.timedelta(hours=hours)
			hour['time'] = d.strftime('%Y-%m-%dT%H:00:00%z')
			
			#  Load defaults from stored JSON object
			for h in weather_data['hourly']:
				if 'time' in h and h['time'] == hour['time']:
					if 'temperature' in h:
						hour['temperature'] = h['temperature']
					if 'windSpeed' in h:
						hour['windSpeed'] = h['windSpeed']
					if 'precipPercent' in h:
						hour['precipPercent'] = h['precipPercent']
					break
			
			#  Update with new values from NOAA query response
			for item in r['properties']['temperature']['values']:
				start_time, end_time = parseInterval(item['validTime'])
				if d >= start_time and d <= end_time:
					hour['temperature'] = degC2degF(item['value'])
					break
			for item in r['properties']['windSpeed']['values']:
				start_time, end_time = parseInterval(item['validTime'])
				if d >= start_time and d <= end_time:
					hour['windSpeed'] = kmph2mph(item['value'])
					break
			for item in r['properties']['probabilityOfPrecipitation']['values']:
				start_time, end_time = parseInterval(item['validTime'])
				if d >= start_time and d <= end_time:
					hour['precipPercent'] = item['value']
					break
					
			hourly_data.append(hour)

		weather_data['hourly'] = hourly_data
	else:
		log('Status code {} returned for {}'.format(response.status_code, weather_data['forecastGridDataURL']))
		log('The hourly forecasts have not been updated. Some other data elements may have been updated however.')

	#-----------------------------   A l e r t s   -----------------------------#

	#  Get any active alerts for this location
	response = requests.get(weather_data['alertsURL'], headers=headers)
	if response.status_code == 200:
		r = response.json()
		#print(json.dumps(r['features'], indent=4))
		alerts = []
		now = datetime.datetime.now(local_tz)
		for item in r['features']:
			onset_time = datetime.datetime.strptime(item['properties']['onset'], '%Y-%m-%dT%H:%M:%S%z')
			expires_time = datetime.datetime.strptime(item['properties']['expires'], '%Y-%m-%dT%H:%M:%S%z')
			
			if item['properties']['messageType'] == 'Cancel':
				#  Remove the referenced alerts from the list
				for ref in item['properties']['references']:
					for a in alerts:
						if a['id'] == ref['identifier']:
							alerts.remove(a)
			elif item['properties']['messageType'] == 'Update':
				#  Replace the referenced alerts with this one  
				#  (TODO: do we need to do a scan for duplicates after this?)
				for ref in item['properties']['references']:
					for a in alerts:
						if a['id'] == ref['identifier']:
							a['id'] = item['properties']['id'],
							a['onset'] = item['properties']['onset']
							a['expires'] = item['properties']['expires']
							a['headline'] = item['properties']['headline']
							a['description'] = item['properties']['description']
			else:
				#  Add the alert to the list
				if onset_time <= now and expires_time >= now:
					alerts.append({
						'id': item['properties']['id'],
						'onset': item['properties']['onset'],
						'expires': item['properties']['expires'],
						'headline': item['properties']['headline'],
						'description': item['properties']['description']
					})

		#  Put the alerts into the JSON object
		weather_data['alerts'] = alerts
		
	else:
		log('Status code {} returned for {}'.format(response.status_code, weather_data['alertsURL']))
		log('The alerts have not been updated. Some other data elements may have been updated however.')

	#  Serialize the JSON object to a file
	try:	
		with open(weather_data_file, 'w') as f:
			json.dump(weather_data, f)
	except Exception as e:
		log('Failed while writing the JSON object to the "{}" file'.format(weather_data_file))
		log(e)
		exit(1)
		
	#print(json.dumps(weather_data, indent=4))

	#  Wait for 30 minutes
	time.sleep(30 * 60)

